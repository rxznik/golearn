# Мапы в Go (map)

**Определение map:** структура данных в Go, реализующая хэш-таблицу для хранения пар ключ-значение.

Из определения следует, что операции над map (вставка, удаление, поиск) выполняются в среднем за константное время O(1).

**Определение hash-функции:** функция, преобразующая входные данные в числовое значение (хэш), используемое как индекс для доступа к ячейке хэш-таблицы.

**Основные свойства hash-функции:**
* **Детерминизм** — одинаковые входные данные всегда дают одинаковый хэш.
* **Быстрота** — вычисление хэша должно занимать минимальное время.
* **Устойчивость к коллизиям** — минимизация вероятности совпадения хэшей для разных ключей.
* **Равномерность распределения** — хэши должны равномерно заполнять доступный диапазон.

**Метод цепочек:** при коллизии элементы с одинаковым хэшем объединяются в связанный список внутри бакета.

**Метод открытой адресации:** при коллизии элемент помещается в следующий доступный бакет согласно алгоритму поиска (например, линейное пробирование).

## Map до Go 1.24

Элементы (ключ-значение) группируются в бакеты по 8 пар. Распределение по бакетам определяется по `n-1` младшим битам хэша ключа, где `n = log₂(количество бакетов)`.

Хэш-функция возвращает 64-битное значение. В начале каждого бакета хранится массив из 8 старших битов хэшей (tophash) для быстрого предварительного поиска:
1. Сначала проверяется массив tophash. Если совпадение не найдено, переход к следующему бакету (если есть).
2. После нахождения совпадающего tophash выполняется полное сравнение ключей.

**Почему поиск по tophash быстрее, чем по ключам?**  
Сравнение 8-битных tophash требует меньше операций, чем сравнение полных ключей (особенно для сложных структур или длинных строк). Кроме того:
- tophash хранится в компактном массиве, что улучшает использование кэша процессора.
- Предварительная фильтрация по tophash сокращает количество полных проверок ключей, которые могут быть ресурсоемкими.

**Борьба с коллизиями:** Используются overflow-бакеты, связанные в цепочки.

**Проблемы:**
* **Кэш-промахи:** При итеративном сравнении ключей процессор загружает данные кэш-линиями (64 байта), но сравнение одного ключа может привести к вытеснению кэша из-за переключения потоков ОС.
* **Неэффективность связанных списков:** Overflow-бакеты расположены в произвольных участках памяти, что увеличивает вероятность кэш-промахов.

**Load factor:** При достижении 6.5 элементов на бакет в среднем происходит рехеширование (увеличение числа бакетов и перераспределение данных).

## Map в Go 1.24+

Теперь map реализована на основе Swiss Table с использованием инструкции SIMD.

Элементы группируются в группы по 16 пар. Хэш-функция возвращает 64 бита, которые делятся на:
- `h1` (57 бит) — определяет группу через `n-1` младших бит.
- `h2` (7 бит + 1 бит-флаг) — хранится в массиве `m1` (16 байт) в начале группы.

**Поиск с использованием SIMD:**  
Современные процессоры поддерживают SIMD-инструкции (Single Instruction, Multiple Data), которые позволяют сравнить 16 байтов массива `m1` с искомым `h2` за одну операцию. Результат — битовая маска, указывающая потенциальные совпадения. Это ускоряет поиск в 5-10 раз. SIMD может за раз провести операцию над 32 байтами (8 чисел int32, 4 числа int64 и т.д.).

**Борьба с коллизиями:** Используется метод открытой адресации с линейным пробированием.

**Преимущества:**
* **Локализация данных:** Элементы группы хранятся последовательно в памяти, что минимизирует кэш-промахи.
* **Отсутствие цепочек:** Устранена необходимость в overflow-бакетах, что улучшает предсказуемость доступа к памяти.
* **Векторизация операций:** SIMD позволяет обрабатывать несколько элементов одновременно.

**Важный факт:** Go автоматически выбирает реализацию map, в зависимости от наличия поддержки инструкции SIMD в процессоре, также можно выключить новую реаизацию с помощью `GOEXPERIMENT=noswissmap`.